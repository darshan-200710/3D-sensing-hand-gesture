<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudarshan Chakra - Hand Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            z-index: 2;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            transform: scaleX(-1);
            background: #000;
            box-shadow: 0 0 15px rgba(255, 165, 0, 0.2);
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6;
        }

        #ui {
            position: absolute;
            top: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            pointer-events: none;
            user-select: none;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 2rem;
            text-transform: uppercase;
            background: linear-gradient(to right, #FFD700, #FF4500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
        }

        #status-box {
            margin-top: 10px;
            font-size: 1.1rem;
            color: #00d2ff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 210, 255, 0.5);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .key {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 3px solid #555;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .key span {
            margin-right: 10px;
            font-size: 1.2rem;
        }

        .active-gesture {
            border-left-color: #FFD700;
            background: rgba(100, 50, 0, 0.6);
            transform: translateX(10px);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 1.2rem;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #start-btn {
            background: linear-gradient(45deg, #FFD700, #FF4500);
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            border-radius: 30px;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
            transition: transform 0.2s;
        }

        #start-btn:active {
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            #video-container {
                width: 120px;
                height: 90px;
                bottom: 10px;
                left: 10px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .key {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
        }
    </style>
</head>

<body>

    <div id="overlay">
        <button id="start-btn">ENTER DIVYA ASTRA</button>
    </div>

    <div id="loader" style="display:none;">Summoning Particles...</div>

    <div id="ui">
        <h1>Divya Astra</h1>
        <div id="status-box">SYSTEM: WAITING...</div>

        <div class="controls">
            <div class="key" id="hint-move"><span>‚úã</span> Move Hand: Control Position</div>
            <div class="key" id="hint-zoom"><span>üîç</span> Move Closer: Zoom In</div>
            <div class="key" id="hint-next"><span>‚úåÔ∏è</span> Two Fingers: Next Shape</div>
            <div class="key" id="hint-explode"><span>‚úä</span> Fist: Explode</div>
        </div>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="canvas-container"></div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const CONFIG = {
            particleCount: isMobile ? 5000 : 20000,
            camFov: isMobile ? 90 : 75,
            camZ: 50,
            lerpSpeed: 0.1,
            gestureCooldown: 1200
        };

        // Global State
        let scene, camera, renderer, particles, geometry, material;
        let positions = [], targets = [];
        let clock = new THREE.Clock();

        // Hand State
        let handPos = new THREE.Vector3(0, 0, 0); // Palm Center
        let handRotation = { x: 0, y: 0 };       // Hand Tilt
        let handZoom = 1;                        // Scale based on depth
        let isHandDetected = false;
        let interactionMode = 'idle';
        let lastGestureTime = 0;

        const shapes = ['sudarshan', 'galaxy', 'heart', 'dna', 'saturn', 'sphere'];
        let currentShapeIndex = 0;

        const palettes = [
            [new THREE.Color('#0011ff'), new THREE.Color('#ffcc00'), new THREE.Color('#ff2200')], // Vishnu
            [new THREE.Color('#00d2ff'), new THREE.Color('#3a7bd5'), new THREE.Color('#ff00cc')], // Nebula
            [new THREE.Color('#00F260'), new THREE.Color('#0575E6')], // Nature
            [new THREE.Color('#ffffff'), new THREE.Color('#ff0000')]  // Red/White
        ];

        // --- 1. THREE.JS SETUP ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.015);

            camera = new THREE.PerspectiveCamera(CONFIG.camFov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.camZ;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticles();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(CONFIG.particleCount * 3);
            const colArray = new Float32Array(CONFIG.particleCount * 3);
            const palette = palettes[0];

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;

                posArray[i * 3] = x;
                posArray[i * 3 + 1] = y;
                posArray[i * 3 + 2] = z;

                positions.push(new THREE.Vector3(x, y, z));
                targets.push(new THREE.Vector3(x, y, z));

                const c = palette[Math.floor(Math.random() * palette.length)];
                colArray[i * 3] = c.r;
                colArray[i * 3 + 1] = c.g;
                colArray[i * 3 + 2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
            material = new THREE.PointsMaterial({
                size: 0.5,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            calculateShape('sudarshan');
        }

        // --- 2. SHAPE MATH ---
        function calculateShape(type) {
            const statusBox = document.getElementById('status-box');
            statusBox.innerText = `SHAPE: ${type.toUpperCase()}`;
            statusBox.style.color = (type === 'sudarshan') ? '#FFD700' : '#fff';

            if (type === 'sudarshan') applyPalette(0);

            let scale = 1;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const target = targets[i];
                const p = i / CONFIG.particleCount;

                if (type === 'sudarshan') {
                    scale = 12;
                    if (p < 0.20) {
                        const phi = Math.acos(-1 + (2 * (p / 0.20)));
                        const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                        target.setFromSphericalCoords(scale * 0.25, phi, theta);
                        target.z *= 0.2;
                    } else if (p < 0.60) {
                        const angle = (p - 0.20) * Math.PI * 2 * 150;
                        const spikes = 12;
                        const r = scale * 0.6 + (Math.abs(Math.sin(angle * (spikes / 2))) * 2);
                        target.set(Math.cos(angle) * r, Math.sin(angle) * r, (Math.random() - 0.5) * 0.5);
                    } else {
                        const angle = (p - 0.60) * Math.PI * 2 * 100;
                        const spikes = 24;
                        const r = scale * 1.0 + (Math.pow(Math.sin(angle * (spikes / 2)), 4) * 3);
                        target.set(Math.cos(angle) * r, Math.sin(angle) * r, (Math.random() - 0.5));
                    }
                } else if (type === 'galaxy') {
                    scale = 18;
                    const branches = 3;
                    const branchAngle = (i % branches) * ((Math.PI * 2) / branches);
                    const radius = Math.random();
                    const curve = radius * scale * 1.2;
                    const spread = (Math.random() - 0.5) * radius * 3;
                    target.set(
                        Math.cos(branchAngle + curve) * radius * scale + spread,
                        (Math.random() - 0.5) * (2 - radius),
                        Math.sin(branchAngle + curve) * radius * scale + spread
                    );
                } else if (type === 'heart') {
                    scale = 0.9;
                    const t = p * Math.PI * 2 * 10 + Math.random();
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    target.set(x * scale, y * scale, (Math.random() - 0.5) * 4);
                } else if (type === 'dna') {
                    const t = i * 0.05;
                    const strand = i % 2 === 0 ? 0 : Math.PI;
                    target.set(Math.cos(t + strand) * 5, (i * 0.005) - 25, Math.sin(t + strand) * 5);
                } else if (type === 'saturn') {
                    const planetSize = CONFIG.particleCount * 0.4;
                    if (i < planetSize) {
                        const phi = Math.acos(-1 + (2 * i) / planetSize);
                        const theta = Math.sqrt(planetSize * Math.PI) * phi;
                        target.setFromSphericalCoords(7, phi, theta);
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 12 + Math.random() * 8;
                        target.set(Math.cos(angle) * dist, (Math.random() - 0.5) * 0.5, Math.sin(angle) * dist);
                        target.applyAxisAngle(new THREE.Vector3(1, 0, 0), 0.4);
                    }
                } else if (type === 'sphere') {
                    const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                    const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                    target.setFromSphericalCoords(12, phi, theta);
                }
            }
        }

        // --- 3. ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const posAttr = geometry.attributes.position;
            const currentShape = shapes[currentShapeIndex];

            // 1. POSITION: Smoothly follow hand
            // Map Hand Coordinates (-1 to 1) to World Coordinates (-35 to 35)
            let targetX = 0, targetY = 0, targetZ = 0;

            if (isHandDetected) {
                targetX = handPos.x * 35;
                targetY = handPos.y * -25; // Invert Y

                // 2. SCALE: Zoom based on hand depth
                const targetScale = handZoom;
                particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.1));

                // 3. ROTATION: Tilt with hand
                const targetRotX = handRotation.x;
                const targetRotY = handRotation.y;

                // Blend shape-specific rotation with hand rotation
                if (currentShape === 'sudarshan') {
                    // Sudarshan spins fast on Z, tilts on X/Y with hand
                    particles.rotation.z -= 0.1; // Spin speed
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, targetRotX, 0.1);
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, targetRotY, 0.1);
                } else {
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, targetRotX, 0.1);
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, targetRotY + (time * 0.1), 0.1);
                }
            } else {
                // Idle Animation
                particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, 1, 0.05));
                particles.rotation.y += 0.002;
                // Slowly return to center
                targetX = 0; targetY = 0;
            }

            // Move the entire particle system object
            particles.position.x = THREE.MathUtils.lerp(particles.position.x, targetX, 0.1);
            particles.position.y = THREE.MathUtils.lerp(particles.position.y, targetY, 0.1);

            // Particle behaviors
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const current = positions[i];
                const target = targets[i];

                if (interactionMode === 'explode') {
                    const dir = current.clone().normalize();
                    current.add(dir.multiplyScalar(0.8));
                    current.addScalar((Math.random() - 0.5));
                } else {
                    // Standard lerp to shape target
                    current.x += (target.x - current.x) * CONFIG.lerpSpeed;
                    current.y += (target.y - current.y) * CONFIG.lerpSpeed;
                    current.z += (target.z - current.z) * CONFIG.lerpSpeed;

                    // Vibration for Sudarshan
                    if (currentShape === 'sudarshan' && i > CONFIG.particleCount * 0.5) {
                        current.x += (Math.random() - 0.5) * 0.2;
                        current.y += (Math.random() - 0.5) * 0.2;
                    }
                }
                posAttr.setXYZ(i, current.x, current.y, current.z);
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 4. VISION & LOGIC ---
        function switchShape() {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            calculateShape(shapes[currentShapeIndex]);
            triggerUI('hint-next');
        }
        function applyPalette(index) {
            const palette = palettes[index];
            const colors = geometry.attributes.color;
            const isSudarshan = shapes[currentShapeIndex] === 'sudarshan';
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let c;
                if (isSudarshan && index === 0) {
                    const p = i / CONFIG.particleCount;
                    if (p < 0.20) c = palette[0];
                    else if (p < 0.60) c = palette[1];
                    else c = palette[2];
                } else {
                    c = palette[Math.floor(Math.random() * palette.length)];
                }
                colors.setXYZ(i, c.r, c.g, c.b);
            }
            colors.needsUpdate = true;
        }
        function triggerUI(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.add('active-gesture');
                setTimeout(() => el.classList.remove('active-gesture'), 500);
            }
        }

        function initVision() {
            const video = document.getElementById('webcam');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(onHandResults);

            const cam = new Camera(video, {
                onFrame: async () => await hands.send({ image: video }),
                width: isMobile ? 480 : 640,
                height: isMobile ? 640 : 480,
                facingMode: 'user'
            });
            cam.start();
        }

        function onHandResults(results) {
            document.getElementById('loader').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const lm = results.multiHandLandmarks[0];

                // 1. Position: Use Middle Finger MCP (Joint 9) for stable center
                const x = (lm[9].x - 0.5) * 2;
                const y = (lm[9].y - 0.5) * 2;
                handPos.lerp(new THREE.Vector3(x, y, 0), 0.2);

                // 2. Zoom: Distance between Wrist (0) and Middle Finger Tip (12)
                // Closer hand = larger distance = Zoom In
                const depthDist = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                const zoomFactor = THREE.MathUtils.mapLinear(depthDist, 0.2, 0.6, 0.5, 2.0); // Map size to scale
                handZoom = Math.max(0.3, Math.min(zoomFactor, 3.0)); // Clamp scale

                // 3. Rotation: Calculate Orientation
                // Tilt X (Forward/Back): Wrist Y vs Middle Finger Y
                // Tilt Y (Left/Right): Thumb MCP X vs Pinky MCP X
                const tiltX = (lm[0].y - lm[9].y) * 3 - 1.5; // Offset to face forward
                const tiltY = (lm[17].z - lm[5].z) * 5;      // Approximation using Z depth diff
                // Simple version:
                handRotation.x = (lm[9].y - 0.5) * 1.5; // Look up/down based on screen Y
                handRotation.y = (lm[9].x - 0.5) * 1.5; // Look left/right based on screen X

                detectGesture(lm);
            } else {
                isHandDetected = false;
                interactionMode = 'idle';
                document.getElementById('status-box').innerText = "SYSTEM: IDLE";
            }
        }

        function detectGesture(lm) {
            const isIndexUp = lm[8].y < lm[6].y;
            const isMiddleUp = lm[12].y < lm[10].y;
            const isRingUp = lm[16].y < lm[14].y;
            const isPinkyUp = lm[20].y < lm[18].y;
            const fingersUp = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;
            const now = Date.now();
            const statusLabel = document.getElementById('status-box');

            if (fingersUp === 0) {
                interactionMode = 'explode';
                statusLabel.innerText = "GESTURE: EXPLODE";
                statusLabel.style.color = '#ff3333';
                triggerUI('hint-explode');
            } else if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp) {
                interactionMode = 'idle';
                statusLabel.innerText = "GESTURE: SWITCH";
                statusLabel.style.color = '#00ff88';
                if (now - lastGestureTime > CONFIG.gestureCooldown) {
                    switchShape();
                    lastGestureTime = now;
                }
            } else {
                interactionMode = 'idle';
                statusLabel.innerText = "SYSTEM: TRACKING";
                statusLabel.style.color = '#fff';
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('loader').style.display = 'block';
            initThree();
            initVision();
        });
    </script>
</body>

</html>